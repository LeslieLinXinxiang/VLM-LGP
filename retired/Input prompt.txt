#目前的相关内容:
##house.lgp:
'''
        # /home/leslie/Projects/VLM_LGP/rai/test/house_stacking/house.lgp 

fol: <house.fol>


terminal: " ( poseEq base_target base_handle) ( poseEq cyl3_target cyl3) ( poseEq cyl4_target cyl4)  ( poseEq cyl1_target cyl1) ( poseEq cyl2_target cyl2) ( poseEq roof_target roof_handle) "

genericCollisions: true

coll:  [ cyl2 base cyl2 base cyl4 base cyl1 base cyl3 base table base cyl1 roof cyl2 roof cyl3 roof cyl4 roof base roof]
'''
'''
##house.fol
        QUIT
WAIT
ANY
Terminate

FOL_World{
  hasWait=false
  gamma = 1.
  stepCost = 1.
  timeCost = 0.
}

### basic predicates
is_gripper
is_object
is_place
is_pose
is_box
is_sphere
is_capsule
is_cylinder 
#### 增加cylinder

### predicates to help formulating rules
on
busy
movable


### predicates to help prune tree
INFEASIBLE
INFEASIBLE_pick

### skeleton symbols
above
touch
impulse
restingOn
poseEq
push_
stable
stableOn
quasiStaticOn
dynamic
dynamicOn
liftDownUp

### initial state (generated by the code)
START_STATE {}

### RULES

#####################################################################

### Reward
REWARD {
}

#####################################################################

DecisionRule pick_touch {
  Obj, From, Hand, 
  { (is_gripper Hand) (is_object Obj) (is_cylinder Obj)! (on From Obj) (is_place From) (busy Hand)! }
  { (on From Obj)! (above Obj From)! (touch Obj From)! (stable From Obj)! (stableOn From Obj)!  #deletes
    (on Hand Obj) (busy Hand) (movable Obj)  #logic
    (touch Hand Obj) (stable Hand Obj)  #geometric
    }
}

#####################################################################

DecisionRule place_straightOn {
  Obj, Hand, To,
  { (is_gripper Hand) (is_object Obj) (on Hand Obj) (is_place To) (busy Obj)! }
  { (busy Hand)! (on Hand Obj)! (stable Hand Obj)! (touch Hand Obj)! (movable Obj)!  #deletes
    (on To Obj)  #logic
    (stableOn To Obj)  #geometric
    }
}

#####################################################################

DecisionRule handover {
  Obj, Hand, To,
  { (is_gripper Hand) (is_object Obj) (on Hand Obj) (is_gripper To) (busy Obj)! (busy To)! }
  { (busy Hand)! (on Hand Obj)! (stable Hand Obj)! (touch Hand Obj)!  #deletes
    (on To Obj) (busy To) #logic
    (touch To Obj) (stable To Obj)  #geometric
    }
}

#####################################################################

DecisionRule poseEq {
  Obj, To,
  { (movable Obj) (is_pose To) }
  { #deletes
    #logic
    (poseEq To Obj)  #geometric
    }
}

#####################################################################

Rule chainMovables {
  Obj1, Obj2,
  { (is_object Obj1) (is_object Obj2) (on Obj1 Obj2) (movable Obj1) }
  { (movable Obj2) }
}

#####################################################################

DecisionRule pick_cylinder {
  Obj, From, Hand, 
  { (is_gripper Hand) (is_object Obj) (is_cylinder Obj) (on From Obj) (is_place From) (busy Hand)! }
  { (on From Obj)! (above Obj From)! (touch Obj From)! (stable From Obj)! (stableOn From Obj)!  #deletes
    (on Hand Obj) (busy Hand) (movable Obj)  #logic
    (touch Hand Obj) (stable Hand Obj)  #geometric
    }
}
'''

'''  
##house.g
        # /home/leslie/Projects/VLM_LGP/rai/test/house_stacking/house.g (Version 2.1)

world {}

### --- 桌子和机器人 ---
table (world) { shape:ssBox, size:[2. 2. .1 .02], Q:"t(0 0 .6)", color:[.3 .3 .3], contact:1, logical:{ is_place } }

Prefix: "l_"
Include: <../LGP/newLGP/problems/rai-robotModels/panda/panda.g>
Prefix: False
Edit l_panda_base (table): { Q: "t(0 -.3 .05) d(90 0 0 1)" } # ## CORRECTED ## 机器人向前移动，离工作区更近

### --- 房屋组件定义 ---

# ## CORRECTED Z-COORDINATES AND POSITIONS ##
# Z-offset for objects on table = 0.05 (table half-height) + object_half_height

#### 1. 底座 (带把手) 
# z_rel = 0.05 + (0.04/2) = 0.07
base_handle (table) { Q:"t(0 0 .12)", joint:rigid, shape:ssBox, size:[.04 .04 .06 .002], color:[.5 .5 .5], contact:1, mass:.5, logical:{ is_object } }
base (base_handle) { Q:"t(0 0 -.05)", shape:ssBox, size:[.5 .4 .04 .002], color:[.8 .8 .8], logical:{ is_object } }

# 2. 四根圆柱 (加粗加高) 
# z_rel = 0.05 + (0.2/2) = 0.15
cyl1 (table) { Q:"t(-0.4 0 .1)", joint:rigid, shape:cylinder, size:[.1 .04], color:[1 1 0], contact:1, mass:.2, logical:{ is_object  , is_cylinder } }
cyl2 (table) { Q:"t(0.4 0 .1)", joint:rigid, shape:cylinder, size:[.1 .04], color:[1 1 0], contact:1, mass:.2, logical:{ is_object  , is_cylinder } }
cyl3 (table) { Q:"t(-0.4 0.2 .1)", joint:rigid, shape:cylinder, size:[.1 .04], color:[1 1 0], contact:1, mass:.2, logical:{ is_object  , is_cylinder} }
cyl4 (table) { Q:"t(0.4 0.2 .1)", joint:rigid, shape:cylinder, size:[.1 .04], color:[1 1 0], contact:1, mass:.2, logical:{ is_object  , is_cylinder} }

# 3. 屋顶 (平面，带把手) 
# z_rel = 0.05 + (0.04/2) = 0.07
roof_handle (table) { Q:"t(-0.5 -0.4 .12)", joint:rigid, shape:ssBox, size:[.04 .04 .06 .002], color:[1 .5 0], contact:1, mass:.5, logical:{ is_object, is_box } }
roof (roof_handle) { Q:"t(0 0 -.05)", shape:ssBox, size:[.5 .4 .04 .002], color:[1 0 0], logical:{ is_place} }



 
# 1. 底座的最终放置位置 
base_target (table) { Q:"t(0 .3 .12) d(0 0 0 1)", logical:{ is_pose } }  

# 2. 在“底座最终位置”上定义四个柱子的目标 
cyl1_target (table) { Q:"t(-0.15 0.2 0.14) d(0 0 0 1)", logical:{ is_pose } }
cyl2_target (table) { Q:"t(0.15 0.2 0.14) d(0 0 0 1)", logical:{ is_pose } }
cyl3_target (table) { Q:"t(-0.15 0.4 0.14) d(0 0 0 1)", logical:{ is_pose } }
cyl4_target (table) { Q:"t(0.15 0.4 0.14) d(0 0 0 1)", logical:{ is_pose } }



# 3. 在“底座最终位置”上定义屋顶的目标 
roof_target (base_target) { Q:"t(0 0 0.14) d(0 0 0 1)", logical:{ is_pose } }
'''


#VLM需要输出的内容规则:
##input: 一张场景搭建完成的图片
##output: 基于给定的.lgp格式的, 完整的文件内容.
具体的, lgp文件分为四个部分:
###fol文件引用:引用哪个fol规则, 在目前场景下, 默认使用house.fol,输出格式为:fol: <house.fol>
###terminal: 核心输出内容, 需要提供给LGP的目标
在当前的逻辑下,程序会严格根据terminal的先后顺序先后执行这些任务, 因此在生成terminal的任务拆分代码时需要考虑到这个任务的执行顺序是否符合真实世界的物理规则, 例如在真实世界执行stacking任务时, 你无法先放置上层objects再放置下层, 这不符合真实世界的物理规律, 在现有谓词中, terminal能够调用的skeleton symbols可以参考先前提供的house.fol中的skeleton symbols, 在当前stacking任务中,需要执行精确位置放置时, 默认使用poseEq, 在仅需执行简单的放置任务, 无需精确放置时时可以直接使用on指令.
具体单个terminal的输出规则为:
每个单独的括号对中代表一个sub-terminal, 括号内容由三组词汇组成

###genericCollisions
默认为true

###碰撞约束
非常重要的约束, 在仿真中的穿透仅仅只会导致穿模, 但在真实世界中会导致不必要的碰撞和破坏, 因此需要精确地约束哪些物体之间需要避免相互碰撞, 不过这里允许一定程度的过度约束, 例如在先前提供的house.lgp文件中:coll:  [ cyl2 base cyl2 base cyl4 base cyl1 base cyl3 base table base cyl1 roof cyl2 roof cyl3 roof cyl4 roof base roof]中, roof与理论上可能发生碰撞的物体都进行了碰撞约束. 



